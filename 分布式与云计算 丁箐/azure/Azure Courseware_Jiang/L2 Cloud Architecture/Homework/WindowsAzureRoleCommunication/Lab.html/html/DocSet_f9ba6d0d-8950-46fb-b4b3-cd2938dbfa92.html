<html dir="ltr" xmlns:MSHelp="http://msdn.microsoft.com/mshelp" xmlns:dt="uuid:C2F41010-65B3-11d1-A29F-00AA00C14882" xmlns:xlink="http://www.w3.org/1999/xlink">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="save" content="history" />
    <xml>
      <MSHelp:TOCTitle Title="Exercise 2: Using Internal Endpoints for Inter-Role Communication" />
      <MSHelp:RLTitle Title="Exercise 2: Using Internal Endpoints for Inter-Role Communication" />
      <MSHelp:Attr Name="DocSet" Value="docSet" />
      <MSHelp:Attr Name="TopicType" Value="kbOrient" />
      <MSHelp:Attr Name="Locale" Value="kbEnglish" />
      <MSHelp:Attr Name="AssetId" Value="{GUID}" />
    </xml>
    <title>Exercise 2: Using Internal Endpoints for Inter-Role Communication</title>
    <link rel="stylesheet" type="text/css" href="../local/Classic.css" />
    <script src="../local/EventUtilities.js" type="text/javascript" language="jscript"> </script>
    <script src="../local/SplitScreen.js" type="text/javascript" language="jscript"> </script>
    <script src="../local/Dropdown.js" type="text/javascript" language="jscript"> </script>
    <script src="../local/script.js" type="text/javascript" language="jscript"> </script>
  </head>
  <body>
    <input type="hidden" id="userDataCache" class="userDataStyle" />
    <input type="hidden" id="hiddenScrollOffset" />
    <img id="dropDownImage" style="display:none; height:0; width:0;" alt="DropDown image" src="../local/drpdown.gif" />
    <img id="dropDownHoverImage" style="display:none; height:0; width:0;" alt="DropDownHover image" src="../local/drpdown_orange.gif" />
    <img id="collapseImage" style="display:none; height:0; width:0;" alt="Collapse image" src="../local/collapse_all.gif" />
    <img id="expandImage" style="display:none; height:0; width:0;" alt="Expand image" src="../local/expand_all.gif" />
    <img id="collapseAllImage" style="display:none; height:0; width:0;" alt="CollapseAll image" src="../local/collall.gif" />
    <img id="expandAllImage" style="display:none; height:0; width:0;" alt="ExpandAll image" src="../local/expall.gif" />
    <img id="copyImage" style="display:none; height:0; width:0;" alt="Copy image" src="../local/copycode.gif" />
    <img id="copyHoverImage" style="display:none; height:0; width:0;" alt="CopyHover image" src="../local/copycodeHighlight.gif" />
    <div id="header">
      <table width="100%" id="topTable">
        <tr id="headerTableRow1">
          <td align="left">
            <span id="runningHeaderText">Windows Azure:  Worker Role Communication</span>
          </td>
        </tr>
        <tr id="headerTableRow2">
          <td align="left">
            <span id="nsrTitle">Exercise 2: Using Internal Endpoints for Inter-Role Communication</span>
          </td>
        </tr>
        <tr id="headerTableRow3">
          <td />
        </tr>
      </table>
      <table width="100%" id="bottomTable" cellspacing="0" cellpadding="0">
        <tr>
          <td>
            <span onclick="ExpandCollapseAll(toggleAllImage)" onkeypress="ExpandCollapseAll_CheckKey(toggleAllImage)" tabindex="0" style="cursor:default;display:none;">
              <img id="toggleAllImage" class="toggleAll" alt="CollapseAll image" src="../local/collall.gif" />
              <label id="collapseAllLabel" for="toggleAllImage" style="display: none;">Collapse All</label>
              <label id="expandAllLabel" for="toggleAllImage" style="display: none;">Expand All</label> </span>
            <span id="languageFilterToolTip" onmouseover="languageFilterImage.src=dropDownHoverImage.src;" onmouseout="languageFilterImage.src=dropDownImage.src;" tabindex="0" style="cursor:default;">
              <img id="languageFilterImage" alt="DropDown image" src="../local/drpdown.gif" />
              <label id="showAllLabel" for="languageFilterImage" style="display: none;">Language Filter: All</label>
              <label id="multipleLabel" for="languageFilterImage" style="display: none;">Language Filter: Multiple</label>
              <label id="vbLabel" for="languageFilterImage" style="display: none;">Language Filter: Visual Basic</label>
              <label id="csLabel" for="languageFilterImage" style="display: none;">Language Filter: C#</label>
            </span>
          </td>
        </tr>
      </table>
      <div id="languageSpan">
        <input type="checkbox" name="languageFilter" onclick="SetLanguage(this)" id="vbUsageCheckbox" />
        <label class="languageFilter" for="vbUsageCheckbox">Visual Basic Usage</label>
        <br />
        <input type="checkbox" name="languageFilter" onclick="SetLanguage(this)" id="csCheckbox" />
        <label class="languageFilter" for="csCheckbox">C#</label>
        <br />
      </div>
    </div>
    <div id="mainSection">
      <div id="mainBody">
        <div id="allHistory" class="saveHistory" onsave="saveAll()" onload="loadAll()" />
        <p>So far, even though multiple instances of the worker role can each host its own endpoint for the chat service, they all operate as independent servers. Clients connected to a given instance are unable to exchange messages with peers in other worker role instances because roles do not share session information.</p>
        <p>In this exercise, you extend the worker role implementation to allow different instances to exchange session information and client notifications over an internal endpoint. To forward messages and session activation events, worker roles need to implement not only the incoming contract of the chat service but also the callback contract implemented by clients. This change allows roles to act as a bridge between peers active in different roles and changes the flow of information in the following manner.</p>
        <br />
        <p><b>Client Registration</b></p>
        <p>During registration, worker roles notify every other worker role through their internal endpoints. Each alerted worker role then notifies its directly connected clients about the new session.</p>
        <p>
          <img src="images\f26a537c-abe4-43c4-923a-d35ca8e33993.png" />
        </p>
        <p>
          <b>Figure 1</b>
          <br />
          <i>Roles exchanging session information via an internal endpoint</i>
        </p>
        <br />
        <ol>
          <li><b>Client 1</b> calls the <b>Register</b> operation to start a new session in <b>Worker Role A</b>.</li>
          <li><b>Worker Role A</b> registers the session with its Session Manager and then calls <b>UpdateClientList</b> in each instance of the internal channel endpoint to notify other worker roles about the new session.</li>
          <li><b>Worker Role B </b>receives the notification and then calls <b>UpdateClientList</b> in the callback channel to notify <b>Client 2</b> that <b>Client 1</b> has connected.</li>
        </ol>
        <br />
        <p><b>Sending Messages</b></p>
        <p>When sending messages to peers with session in other worker roles, clients first send the message to their role, which then forwards the message through the callback interface to the second role using an internal endpoint. The target role then delivers the message to the recipient using the callback channel to the client. In this case, only the worker roles for the origin and destination are involved in the exchange.</p>
        <p>
          <img src="images\ac255f45-a287-4544-a2df-31d2e2f7bd62.png" />
        </p>
        <p>
          <b>Figure 2</b>
          <br />
          <i>Users connected to different worker roles exchanging messages</i>
        </p>
        <br />
        <ol>
          <li><b>Client 1</b> calls <b>SendMessage</b> to send the message to <b>Worker Role A</b> indicating <b>Client 2</b> as the recipient.</li>
          <li><b>Worker Role A</b> queries the Session Manager, determines that <b>Client 2</b> has a session in <b>Worker Role B</b> and then calls <b>DeliverMessage</b> over the internal channel endpoint to forward the message only to this role.</li>
          <li><b>Worker Role B</b> receives the message and then calls <b>DeliverMessage</b> to deliver the message to <b>Client 2</b> over the callback channel.</li>
        </ol>
        <br />
        <a name="_Toc249249697" href="#">
          <span />
        </a>
        <p>
          <b>Task 1 – Creating an Inter-Role Communication Endpoint</b>
        </p>
        <p>In this task, you configure the worker role to define an internal endpoint. Next, you update the service host configuration to add a new WCF service endpoint using the callback channel contract and set it to listen at the address provided by the internal endpoint.</p>
        <ol>
          <li>If it is not already open, launch Microsoft Visual Studio 2008 in elevated administrator mode, from <b>Start | All Programs | Microsoft Visual Studio 2008</b> by right clicking the <b>Microsoft Visual Studio 2008</b> shortcut and choosing <b>Run as Administrator</b>.</li>
          <li>In the <b>File</b> menu, choose <b>Open</b> and then <b>Project/Solution</b>. In the <b>Open Project</b> dialog, browse to <b>Ex2-InterRoleCommunication\Begin</b> in the <b>Source</b> folder of the lab, select <b>Begin.sln</b> in the folder for the language of your preference (Visual C# or Visual Basic) and click <b>Open</b>. Alternatively, you may continue with the solution that you obtained after completing <b>Exercise 1</b>.</li>
          <li>Define an internal endpoint for the worker role.  To do this, in <b>Solution Explorer</b>, expand the <b>Roles</b> node in the <b>AzureTalk</b> cloud project, right-click the <b>AzureTalk.Service</b> role and choose <b>Properties</b>. In the role <b>Properties</b> window, change to the <b>Endpoints</b> tab and click <b>Add Endpoint</b>. Set the name of the new endpoint to “<i>NotificationService</i>”, change the <b>Type</b> to “<i>Internal</i>” and leave the <b>Protocol</b> as “<i>tcp</i>”. The worker role will use this TCP endpoint to receive notifications from other worker roles.<p><img src="images\2d1882c5-f15b-4db4-bddb-18eb40708249.png" /></p><p><b>Figure 3</b><br /><i>Defining an internal endpoint for the worker role</i></p><br /></li>
          <li>Press <b>CTRL + S</b> to save the changes to the worker role configuration.</li>
          <li>Open the <b>WorkerRole.cs </b>file<b> </b>(for Visual C# projects) or <b>WorkerRole.vb </b>file (for Visual Basic projects) in the <b>AzureTalk.Service</b> project. </li>
          <li>In the <b>WorkerRole</b> class, define a WCF <b>ChannelFactory</b> member that the worker role will use to create the channel objects for communicating with other roles.<p>(Code Snippet – <i>Windows Azure Worker Role Communication – Ex02 ChannelFactory - CS</i>)</p><div class="code"><span codeLanguage="CSharp"><table width="100%" cellspacing="0" cellpadding="0"><tr><th>C#</th><th><span class="copyCode" onclick="CopyCode(this)" onkeypress="CopyCode_CheckKey(this)" onmouseover="ChangeCopyCodeIcon(this)" onfocusin="ChangeCopyCodeIcon(this)" onmouseout="ChangeCopyCodeIcon(this)" onfocusout="ChangeCopyCodeIcon(this)" tabindex="0"><img class="copyCodeImage" name="ccImage" align="absmiddle" src="../local/copycode.gif" />Copy Code
                  </span></th></tr><tr><td colspan="2"><pre>public class WorkerRole : RoleEntryPoint{<b>  /// &lt;summary&gt;Channel factory for inter-role notifications.&lt;/summary&gt;</b><b>  private static ChannelFactory&lt;IClientNotification&gt; factory;</b>  /// &lt;summary&gt;ServiceHost object for internal and external endpoints.&lt;/summary&gt;  private ServiceHost serviceHost;  ...</pre></td></tr></table></span></div><br /><p>(Code Snippet – <i>Windows Azure Worker Role Communication – Ex02 ChannelFactory - VB</i>)</p><div class="code"><span codeLanguage="VisualBasicUsage"><table width="100%" cellspacing="0" cellpadding="0"><tr><th>Visual Basic</th><th><span class="copyCode" onclick="CopyCode(this)" onkeypress="CopyCode_CheckKey(this)" onmouseover="ChangeCopyCodeIcon(this)" onfocusin="ChangeCopyCodeIcon(this)" onmouseout="ChangeCopyCodeIcon(this)" onfocusout="ChangeCopyCodeIcon(this)" tabindex="0"><img class="copyCodeImage" name="ccImage" align="absmiddle" src="../local/copycode.gif" />Copy Code
                  </span></th></tr><tr><td colspan="2"><pre>Public Class WorkerRole    Inherits RoleEntryPoint<b>' &lt;summary&gt;Channel factory for inter-role notifications.&lt;/summary&gt;</b><b>  Private Shared factory As ChannelFactory(Of IClientNotification)</b>  ' &lt;summary&gt;ServiceHost object for internal and external endpoints.&lt;/summary&gt;  Private serviceHost As ServiceHost...</pre></td></tr></table></span></div><br /><div class="alert"><table width="100%" cellspacing="0" cellpadding="0"><tr><th align="left"><img class="note" src="../local/note.gif" />Note:</th></tr><tr><td>The worker role caches the channel factory, which is a thread-safe object, in a static member to avoid the cost of re-creating it each time it needs to communicate with other worker roles.  </td></tr></table><p /></div><br /></li>
          <li>Update the <b>StartChatService</b> method to configure a new internal endpoint for the service host and create the channel factory for inter-role communication. To do this, insert the following (highlighted) code immediately after the code that defines the external endpoint.<p>(Code Snippet – <i>Windows Azure Worker Role Communication</i>–<i>Ex02 InternalEndpoint - CS</i>)</p><div class="code"><span codeLanguage="CSharp"><table width="100%" cellspacing="0" cellpadding="0"><tr><th>C#</th><th><span class="copyCode" onclick="CopyCode(this)" onkeypress="CopyCode_CheckKey(this)" onmouseover="ChangeCopyCodeIcon(this)" onfocusin="ChangeCopyCodeIcon(this)" onmouseout="ChangeCopyCodeIcon(this)" onfocusout="ChangeCopyCodeIcon(this)" tabindex="0"><img class="copyCodeImage" name="ccImage" align="absmiddle" src="../local/copycode.gif" />Copy Code
                  </span></th></tr><tr><td colspan="2"><pre>/// &lt;summary&gt;/// Starts the service host object for the internal /// and external endpoints of the chat service./// &lt;/summary&gt;/// &lt;param name="retries"&gt;Specifies the number of retries to /// start the service in case of failure.&lt;/param&gt;private void StartChatService(int retries){  ...  // define an external endpoint for client traffic  RoleInstanceEndpoint externalEndPoint =      RoleEnvironment.CurrentRoleInstance.InstanceEndpoints["ChatService"];  this.serviceHost.AddServiceEndpoint(     typeof(IChatService),     binding,     String.Format("net.tcp://{0}/ChatService", externalEndPoint.IPEndpoint));<b>  // define an internal endpoint for inter-role traffic</b><b>  RoleInstanceEndpoint internalEndPoint =</b><b>      RoleEnvironment.CurrentRoleInstance.InstanceEndpoints["NotificationService"];</b><b>  this.serviceHost.AddServiceEndpoint(</b><b>     typeof(IClientNotification),</b><b>     binding,</b><b>     String.Format("net.tcp://{0}/NotificationService", internalEndPoint.IPEndpoint));</b><b>  // create channel factory for inter-role communication</b><b>  WorkerRole.factory = new ChannelFactory&lt;IClientNotification&gt;(binding);</b>  try  {    this.serviceHost.Open();    Trace.TraceInformation("Chat service host started successfully.");  ...}</pre></td></tr></table></span></div><br /><p>(Code Snippet – <i>Windows Azure Worker Role Communication</i>–<i>Ex02 InternalEndpoint - VB</i>)</p><div class="code"><span codeLanguage="VisualBasicUsage"><table width="100%" cellspacing="0" cellpadding="0"><tr><th>Visual Basic</th><th><span class="copyCode" onclick="CopyCode(this)" onkeypress="CopyCode_CheckKey(this)" onmouseover="ChangeCopyCodeIcon(this)" onfocusin="ChangeCopyCodeIcon(this)" onmouseout="ChangeCopyCodeIcon(this)" onfocusout="ChangeCopyCodeIcon(this)" tabindex="0"><img class="copyCodeImage" name="ccImage" align="absmiddle" src="../local/copycode.gif" />Copy Code
                  </span></th></tr><tr><td colspan="2"><pre>''' &lt;summary&gt;''' Starts the service host object for the internal ''' and external endpoints of the chat service.''' &lt;/summary&gt;''' &lt;param name="retries"&gt;Specifies the number of retries to ''' start the service in case of failure.&lt;/param&gt;Private Sub StartChatService(ByVal retries As Integer)  ...  ' define an external endpoint for client traffic  Dim externalEndPoint As RoleInstanceEndpoint = RoleEnvironment.CurrentRoleInstance.InstanceEndpoints("ChatService")  Me.serviceHost.AddServiceEndpoint(GetType(IChatService), binding, String.Format("net.tcp://{0}/ChatService", externalEndPoint.IPEndpoint))<b>  ' define an internal endpoint for inter-role traffic</b><b>  Dim internalEndPoint As RoleInstanceEndpoint = RoleEnvironment.CurrentRoleInstance.InstanceEndpoints("NotificationService")</b><b>  Me.serviceHost.AddServiceEndpoint(GetType(IClientNotification), binding, String.Format("net.tcp://{0}/NotificationService", internalEndPoint.IPEndpoint))</b><b>  ' create channel factory for inter-role communication</b><b>  WorkerRole.factory = New ChannelFactory(Of IClientNotification)(binding)</b>  Try    Me.serviceHost.Open()    Trace.TraceInformation("Chat service host started successfully.")    ...End Sub</pre></td></tr></table></span></div><br /></li>
          <li>Add a new <b>NotifyAllNodes</b> method to the <b>WorkerRole</b> class. The worker role uses this method to inform other roles whenever a client starts or ends a session in this role.<p>(Code Snippet – <i>Windows Azure Worker Role Communication</i>–<i>Ex02 NotifyAllNodes - CS</i>)</p><div class="code"><span codeLanguage="CSharp"><table width="100%" cellspacing="0" cellpadding="0"><tr><th>C#</th><th><span class="copyCode" onclick="CopyCode(this)" onkeypress="CopyCode_CheckKey(this)" onmouseover="ChangeCopyCodeIcon(this)" onfocusin="ChangeCopyCodeIcon(this)" onmouseout="ChangeCopyCodeIcon(this)" onfocusout="ChangeCopyCodeIcon(this)" tabindex="0"><img class="copyCodeImage" name="ccImage" align="absmiddle" src="../local/copycode.gif" />Copy Code
                  </span></th></tr><tr><td colspan="2"><pre><b>/// &lt;summary&gt;</b><b>/// Notifies all available worker roles to update their active sessions list </b><b>/// when a new client connects or disconnects.</b><b>/// &lt;/summary&gt;</b><b>/// &lt;param name="session"&gt;The SessionInformation object for the client.&lt;/param&gt;</b><b>internal static void NotifyAllNodes(SessionInformation session)</b><b>{</b><b>  // iterate over all instances of the internal endpoint except the current role - no need to notify itself</b><b>  var current = RoleEnvironment.CurrentRoleInstance;</b><b>  var endPoints = current.Role.Instances</b><b>                  .Where(instance =&gt; instance != current)</b><b>                  .Select(instance =&gt; instance.InstanceEndpoints["NotificationService"]);</b><b>  foreach (var ep in endPoints)</b><b>  {</b><b>    EndpointAddress address =</b><b>        new EndpointAddress(String.Format("net.tcp://{0}/NotificationService", ep.IPEndpoint));</b><b>    IClientNotification client = WorkerRole.factory.CreateChannel(address);</b><b>    try</b><b>    {</b><b>      client.UpdateClientList(session);</b><b>      ((ICommunicationObject)client).Close();</b><b>    }</b><b>    catch (TimeoutException timeoutException)</b><b>    {</b><b>      Trace.TraceError("Unable to notify worker role instance '{0}'. The service operation timed out. {1}", ep.RoleInstance.Id, timeoutException.Message);</b><b>      ((ICommunicationObject)client).Abort();</b><b>    }</b><b>    catch (CommunicationException communicationException)</b><b>    {</b><b>      Trace.TraceError("Unable to notify worker role instance '{0}'. There was a communication problem. {1} - {2}", ep.RoleInstance.Id, communicationException.Message, communicationException.StackTrace);</b><b>      ((ICommunicationObject)client).Abort();</b><b>    }</b><b>  }</b><b>}</b></pre></td></tr></table></span></div><br /><p>(Code Snippet – <i>Windows Azure Worker Role Communication</i>–<i>Ex02 NotifyAllNodes - VB</i>)</p><div class="code"><span codeLanguage="VisualBasicUsage"><table width="100%" cellspacing="0" cellpadding="0"><tr><th>Visual Basic</th><th><span class="copyCode" onclick="CopyCode(this)" onkeypress="CopyCode_CheckKey(this)" onmouseover="ChangeCopyCodeIcon(this)" onfocusin="ChangeCopyCodeIcon(this)" onmouseout="ChangeCopyCodeIcon(this)" onfocusout="ChangeCopyCodeIcon(this)" tabindex="0"><img class="copyCodeImage" name="ccImage" align="absmiddle" src="../local/copycode.gif" />Copy Code
                  </span></th></tr><tr><td colspan="2"><pre><b>''' &lt;summary&gt;</b><b>''' Notifies all available worker roles to update their active sessions list </b><b>''' when a new client connects or disconnects.</b><b>''' &lt;/summary&gt;</b><b>''' &lt;param name="session"&gt;The SessionInformation object for the client.&lt;/param&gt;</b><b>Friend Shared Sub NotifyAllNodes(ByVal session As SessionInformation)</b><b>  ' iterate over all instances of the internal endpoint except the current role - no need to notify itself</b><b>  Dim current = RoleEnvironment.CurrentRoleInstance</b><b>  Dim endPoints = current.Role.Instances.Where(Function(instance) instance IsNot current).Select(Function(instance) instance.InstanceEndpoints("NotificationService"))</b><b>  For Each ep In endPoints</b><b>    Dim address As New EndpointAddress(String.Format("net.tcp://{0}/NotificationService", ep.IPEndpoint))</b><b>    Dim client As IClientNotification = WorkerRole.factory.CreateChannel(address)</b><b>    Try</b><b>      client.UpdateClientList(session)</b><b>      CType(client, ICommunicationObject).Close()</b><b>    Catch timeoutException As TimeoutException</b><b>      Trace.TraceError("Unable to notify worker role instance '{0}'. The service operation timed out. {1}", ep.RoleInstance.Id, timeoutException.Message)</b><b>      CType(client, ICommunicationObject).Abort()</b><b>    Catch communicationException As CommunicationException</b><b>      Trace.TraceError("Unable to notify worker role instance '{0}'. There was a communication problem. {1} - {2}", ep.RoleInstance.Id, communicationException.Message, communicationException.StackTrace)</b><b>      CType(client, ICommunicationObject).Abort()</b><b>    End Try</b><b>  Next ep</b><b>End Sub</b></pre></td></tr></table></span></div><br /><div class="alert"><table width="100%" cellspacing="0" cellpadding="0"><tr><th align="left"><img class="note" src="../local/note.gif" />Note:</th></tr><tr><td> Internally, worker roles expose an endpoint that uses the <b>IClientNotification</b> contract. This is the same contract used by worker roles to communicate back with clients.<b> NotifyAllNodes</b> iterates over every instance of the worker role, except the current instance, since the worker role does not need to notify itself, retrieves its internal endpoint, and invokes the <b>UpdateClientList</b> operation to alert each worker role about session activity in the current instance.</td></tr></table><p /></div><br /></li>
          <li>Next, add a new <b>ForwardMessage</b> method to the <b>WorkerRole</b> class. This method uses the internal channel to forward messages from clients in the current role to the role where the target session is active.<p>(Code Snippet – <i>Windows Azure Worker Role Communication</i>–<i>Ex02 ForwardMessage - CS</i>)</p><div class="code"><span codeLanguage="CSharp"><table width="100%" cellspacing="0" cellpadding="0"><tr><th>C#</th><th><span class="copyCode" onclick="CopyCode(this)" onkeypress="CopyCode_CheckKey(this)" onmouseover="ChangeCopyCodeIcon(this)" onfocusin="ChangeCopyCodeIcon(this)" onmouseout="ChangeCopyCodeIcon(this)" onfocusout="ChangeCopyCodeIcon(this)" tabindex="0"><img class="copyCodeImage" name="ccImage" align="absmiddle" src="../local/copycode.gif" />Copy Code
                  </span></th></tr><tr><td colspan="2"><pre><b>/// &lt;summary&gt;</b><b>/// Forwards a message from the current role to the role of the destination session.</b><b>/// &lt;/summary&gt;</b><b>/// &lt;param name="message"&gt;The message to forward.&lt;/param&gt;</b><b>/// &lt;param name="fromSessionId"&gt;The ID of the source session.&lt;/param&gt;</b><b>/// &lt;param name="toSessionId"&gt;The ID of the target session.&lt;/param&gt;</b><b>public static void ForwardMessage(string message, string fromSessionId, string toSessionId)</b><b>{</b><b>  SessionInformation session = SessionManager.GetSession(toSessionId);</b><b>  if (session == null)</b><b>  {</b><b>    return;</b><b>  }</b><b>  // retrieve the endpoint for the role instance where the target session is active</b><b>  var targetRole = RoleEnvironment.CurrentRoleInstance.Role.Instances</b><b>                   .Where(role =&gt; role.Id == session.RoleId).FirstOrDefault();</b><b>  if (targetRole != null)</b><b>  {</b><b>    var ep = targetRole.InstanceEndpoints["NotificationService"];</b><b>    if (ep != null)</b><b>    {</b><b>      EndpointAddress address =</b><b>          new EndpointAddress(String.Format("net.tcp://{0}/NotificationService", ep.IPEndpoint));</b><b>      IClientNotification client = WorkerRole.factory.CreateChannel(address);</b><b>      try</b><b>      {</b><b>        client.DeliverMessage(message, fromSessionId, toSessionId);</b><b>        ((ICommunicationObject)client).Close();</b><b>      }</b><b>      catch (TimeoutException timeoutException)</b><b>      {</b><b>        Trace.TraceError("Unable to forward message to instance '{0}'. The service operation timed out. {1}", ep.RoleInstance.Id, timeoutException.Message);</b><b>        ((ICommunicationObject)client).Abort();</b><b>      }</b><b>      catch (CommunicationException communicationException)</b><b>      {</b><b>        Trace.TraceError("Unable to forward message to instance '{0}'. There was a communication problem. {1} - {2}", ep.RoleInstance.Id, communicationException.Message, communicationException.StackTrace);</b><b>        ((ICommunicationObject)client).Abort();</b><b>      }</b><b>    }</b><b>  }</b><b>}</b></pre></td></tr></table></span></div><br /><p>(Code Snippet – <i>Windows Azure Worker Role Communication</i>–<i>Ex02 ForwardMessage - VB</i>)</p><div class="code"><span codeLanguage="VisualBasicUsage"><table width="100%" cellspacing="0" cellpadding="0"><tr><th>Visual Basic</th><th><span class="copyCode" onclick="CopyCode(this)" onkeypress="CopyCode_CheckKey(this)" onmouseover="ChangeCopyCodeIcon(this)" onfocusin="ChangeCopyCodeIcon(this)" onmouseout="ChangeCopyCodeIcon(this)" onfocusout="ChangeCopyCodeIcon(this)" tabindex="0"><img class="copyCodeImage" name="ccImage" align="absmiddle" src="../local/copycode.gif" />Copy Code
                  </span></th></tr><tr><td colspan="2"><pre><b>' &lt;summary&gt;</b><b>' Forwards a message from the current role to the role of the destination session.</b><b>' &lt;/summary&gt;</b><b>' &lt;param name="message"&gt;The message to forward.&lt;/param&gt;</b><b>' &lt;param name="fromSessionId"&gt;The ID of the source session.&lt;/param&gt;</b><b>' &lt;param name="toSessionId"&gt;The ID of the target session.&lt;/param&gt;</b><b>Public Shared Sub ForwardMessage(ByVal message As String, ByVal fromSessionId As String, ByVal toSessionId As String)</b><b>  Dim session As SessionInformation = SessionManager.GetSession(toSessionId)</b><b>  If session Is Nothing Then</b><b>    Return</b><b>  End If</b><b>  ' retrieve the endpoint for the role instance where the target session is active</b><b>  Dim targetRole = RoleEnvironment.CurrentRoleInstance.Role.Instances.Where(Function(role) role.Id = session.RoleId).FirstOrDefault()</b><b>  If targetRole IsNot Nothing Then</b><b>    Dim ep = targetRole.InstanceEndpoints("NotificationService")</b><b>    If ep IsNot Nothing Then</b><b>      Dim address As New EndpointAddress(String.Format("net.tcp://{0}/NotificationService", ep.IPEndpoint))</b><b>      Dim client As IClientNotification = WorkerRole.factory.CreateChannel(address)</b><b>      Try</b><b>        client.DeliverMessage(message, fromSessionId, toSessionId)</b><b>        CType(client, ICommunicationObject).Close()</b><b>      Catch timeoutException As TimeoutException</b><b>        Trace.TraceError("Unable to forward message to instance '{0}'. The service operation timed out. {1}", ep.RoleInstance.Id, timeoutException.Message)</b><b>        CType(client, ICommunicationObject).Abort()</b><b>      Catch communicationException As CommunicationException</b><b>        Trace.TraceError("Unable to forward message to instance '{0}'. There was a communication problem. {1} - {2}", ep.RoleInstance.Id, communicationException.Message, communicationException.StackTrace)</b><b>        CType(client, ICommunicationObject).Abort()</b><b>      End Try</b><b>    End If</b><b>  End If</b><b>End Sub</b></pre></td></tr></table></span></div><br /><div class="alert"><table width="100%" cellspacing="0" cellpadding="0"><tr><th align="left"><img class="note" src="../local/note.gif" />Note:</th></tr><tr><td>The <b>ForwardMessage</b> method retrieves the target session information to determine its role ID, obtains a reference to the corresponding worker role and then retrieves its internal endpoint.  Finally, it creates a new channel instance and calls the <b>DeliverMessage</b> operation to forward the message to the target worker role over the internal endpoint.</td></tr></table><p /></div></li>
        </ol>
        <p>
          <b>
          </b>
        </p>
        <a name="_Toc249249698" href="#">
          <span />
        </a>
        <p>
          <b>Task 2 – Receiving Notifications from Other Worker Roles</b>
        </p>
        <p>In order to allow communication between clients connected to different instances of the service, worker roles must act as proxies for remote clients. Clients send messages and notifications to their role, which in turn forwards them to the remote worker role using the same contract that the service uses to communicate back with clients. </p>
        <p>In this task, you extend the chat service class to implement the client notification contract. </p>
        <ol>
          <li>Open the <b>ChatService.cs</b> file (for Visual C# projects) or <b>ChatService.vb</b> file (for Visual Basic projects) in the <b>AzureTalk.Service</b> project. </li>
          <li>Add the <b>IClientNotification</b> interface to the list of contracts implemented by the <b>ChatService</b> class.<div class="code"><span codeLanguage="CSharp"><table width="100%" cellspacing="0" cellpadding="0"><tr><th>C#</th><th><span class="copyCode" onclick="CopyCode(this)" onkeypress="CopyCode_CheckKey(this)" onmouseover="ChangeCopyCodeIcon(this)" onfocusin="ChangeCopyCodeIcon(this)" onmouseout="ChangeCopyCodeIcon(this)" onfocusout="ChangeCopyCodeIcon(this)" tabindex="0"><img class="copyCodeImage" name="ccImage" align="absmiddle" src="../local/copycode.gif" />Copy Code
                  </span></th></tr><tr><td colspan="2"><pre>public class ChatService : IChatService, IClientNotification{   ...</pre></td></tr></table></span></div><br /><div class="code"><span codeLanguage="VisualBasicUsage"><table width="100%" cellspacing="0" cellpadding="0"><tr><th>Visual Basic</th><th><span class="copyCode" onclick="CopyCode(this)" onkeypress="CopyCode_CheckKey(this)" onmouseover="ChangeCopyCodeIcon(this)" onfocusin="ChangeCopyCodeIcon(this)" onmouseout="ChangeCopyCodeIcon(this)" onfocusout="ChangeCopyCodeIcon(this)" tabindex="0"><img class="copyCodeImage" name="ccImage" align="absmiddle" src="../local/copycode.gif" />Copy Code
                  </span></th></tr><tr><td colspan="2"><pre>Public Class ChatService    Implements IChatService, IClientNotification...</pre></td></tr></table></span></div><br /></li>
          <li>Add the <b>UpdateClientList</b> method to the <b>ChatService</b> class. Worker role instances use this operation to notify their peers whenever a client starts or ends a session.<p> (Code Snippet – <i>Windows Azure Worker Role Communication</i>–<i>Ex02 UpdateClientList - CS</i>)</p><div class="code"><span codeLanguage="CSharp"><table width="100%" cellspacing="0" cellpadding="0"><tr><th>C#</th><th><span class="copyCode" onclick="CopyCode(this)" onkeypress="CopyCode_CheckKey(this)" onmouseover="ChangeCopyCodeIcon(this)" onfocusin="ChangeCopyCodeIcon(this)" onmouseout="ChangeCopyCodeIcon(this)" onfocusout="ChangeCopyCodeIcon(this)" tabindex="0"><img class="copyCodeImage" name="ccImage" align="absmiddle" src="../local/copycode.gif" />Copy Code
                  </span></th></tr><tr><td colspan="2"><pre><b>/// &lt;summary&gt;</b><b>/// Receives notifications when a new client connects or disconnects in another worker role.</b><b>/// &lt;/summary&gt;</b><b>/// &lt;param name="clientInfo"&gt;The ClientInformation object for the client.&lt;/param&gt;</b><b>public void UpdateClientList(ClientInformation clientInfo)</b><b>{</b><b>  if (clientInfo.IsActive)</b><b>  {</b><b>    SessionInformation session;</b><b>    if (SessionManager.CreateOrUpdateSession(clientInfo.SessionId, clientInfo.UserName, clientInfo.RoleId, null, out session))</b><b>    {</b><b>      Trace.TraceInformation("Remote session '{0}' by user '{1}' has been opened in role '{2}'.", session.SessionId, session.UserName, session.RoleId);</b><b>    }</b><b>  }</b><b>  else</b><b>  {</b><b>    SessionManager.RemoveSession(clientInfo.SessionId);</b><b>    Trace.TraceInformation("Remote session '{0}' by user '{1}' has been closed in role '{2}'.", clientInfo.SessionId, clientInfo.UserName, clientInfo.RoleId);</b><b>  }</b><b>  NotifyConnectedClients(clientInfo);</b><b>}</b></pre></td></tr></table></span></div></li>
          <br />
          <p>(Code Snippet – <i>Windows Azure Worker Role Communication</i>–<i>Ex02 UpdateClientList - VB</i>)</p>
          <div class="code">
            <span codeLanguage="VisualBasicUsage">
              <table width="100%" cellspacing="0" cellpadding="0">
                <tr>
                  <th>Visual Basic</th>
                  <th>
                    <span class="copyCode" onclick="CopyCode(this)" onkeypress="CopyCode_CheckKey(this)" onmouseover="ChangeCopyCodeIcon(this)" onfocusin="ChangeCopyCodeIcon(this)" onmouseout="ChangeCopyCodeIcon(this)" onfocusout="ChangeCopyCodeIcon(this)" tabindex="0">
                      <img class="copyCodeImage" name="ccImage" align="absmiddle" src="../local/copycode.gif" />Copy Code
                  </span>
                  </th>
                </tr>
                <tr>
                  <td colspan="2">
                    <pre><b>' &lt;summary&gt;</b><b>' Receives notifications when a new client connects or disconnects in another worker role.</b><b>' &lt;/summary&gt;</b><b>' &lt;param name="clientInfo"&gt;The ClientInformation object for the client.&lt;/param&gt;</b><b>Public Sub UpdateClientList(ByVal clientInfo As ClientInformation) Implements IClientNotification.UpdateClientList</b><b>  If clientInfo.IsActive Then</b><b>    Dim session As SessionInformation</b><b>    If SessionManager.CreateOrUpdateSession(clientInfo.SessionId, clientInfo.UserName, clientInfo.RoleId, Nothing, session) Then</b><b>      Trace.TraceInformation("Remote session '{0}' by user '{1}' has been opened in role '{2}'.", session.SessionId, session.UserName, session.RoleId)</b><b>    End If</b><b>  Else</b><b>    SessionManager.RemoveSession(clientInfo.SessionId)</b><b>    Trace.TraceInformation("Remote session '{0}' by user '{1}' has been closed in role '{2}'.", clientInfo.SessionId, clientInfo.UserName, clientInfo.RoleId)</b><b>  End If</b><b>  NotifyConnectedClients(clientInfo)</b><b>End Sub</b></pre>
                  </td>
                </tr>
              </table>
            </span>
          </div>
          <br />
          <div class="alert">
            <table width="100%" cellspacing="0" cellpadding="0">
              <tr>
                <th align="left">
                  <img class="note" src="../local/note.gif" />Note:</th>
              </tr>
              <tr>
                <td>The <b>UpdateClientList</b> method determines whether a session is active and then registers it with the Session Manager.  If a session has ended, it calls the Session Manager to remove it. In both cases, it calls <b>NotifyConnectedClients</b> to inform every client connected to the worker role about the session activity.</td>
              </tr>
            </table>
            <p />
          </div>
          <br />
          <li>At this point, you may wish to review the <b>DeliverMessage</b> method, which you implemented in the previous exercise to send messages to the client. Here, you take advantage of this method to implement the <b>DeliverMessage</b> operation of the <b>IClientNotification</b> contract. No additional code is required to fulfill the contract for a Visual C# project. For a Visual Basic project, update the method signature to indicate that the <b>DeliverMessage</b> method implements the <b>DeliverMessage</b> operation of the <b>IClientNotification</b> contract explicitly.<div class="code"><span codeLanguage="VisualBasicUsage"><table width="100%" cellspacing="0" cellpadding="0"><tr><th>Visual Basic</th><th><span class="copyCode" onclick="CopyCode(this)" onkeypress="CopyCode_CheckKey(this)" onmouseover="ChangeCopyCodeIcon(this)" onfocusin="ChangeCopyCodeIcon(this)" onmouseout="ChangeCopyCodeIcon(this)" onfocusout="ChangeCopyCodeIcon(this)" tabindex="0"><img class="copyCodeImage" name="ccImage" align="absmiddle" src="../local/copycode.gif" />Copy Code
                  </span></th></tr><tr><td colspan="2"><pre>''' &lt;summary&gt;''' Delivers a message to a client in the current worker role.''' &lt;/summary&gt;''' &lt;param name="message"&gt;The message to forward.&lt;/param&gt;''' &lt;param name="fromSessionId"&gt;The session ID of the message originator.&lt;/param&gt;''' &lt;param name="toSessionId"&gt;The session ID of the message recipient.&lt;/param&gt;Public Sub DeliverMessage(ByVal message As String, ByVal fromSessionId As String, ByVal toSessionId As String) Implements IClientNotification.DeliverMessage  ' Method ImplementationEnd Sub</pre></td></tr></table></span></div></li>
        </ol>
        <p>
          <b>
          </b>
        </p>
        <a name="_Toc249249699" href="#">
          <span />
        </a>
        <p>
          <b>Task 3 – Sending Notifications to Other Worker Roles</b>
        </p>
        <p>In this task, you update the service to send notifications to other worker roles whenever a new client connects or disconnects and when clients in the current role send messages to peers in different roles. </p>
        <ol>
          <li>Open the <b>ChatService.cs</b> file (for Visual C# projects) or <b>ChatService.vb</b> (for Visual Basic projects) in the <b>AzureTalk.Service</b> project.</li>
          <li>If you implement the code in C#, locate the <b>Register</b> method and insert a call to <b>NotifyAllNodes</b> inside the embedded handler for the <b>Closed</b> event of the channel and immediately following the call to <b>NotifyConnectedClients</b>. In addition, insert a second call to <b>NotifyAllNodes</b> after the call to <b>NotifyConnectedClients</b> in the main body of the method. This ensures that worker roles are alerted both when clients open and when they close a session.<div class="code"><span codeLanguage="CSharp"><table width="100%" cellspacing="0" cellpadding="0"><tr><th>C#</th><th><span class="copyCode" onclick="CopyCode(this)" onkeypress="CopyCode_CheckKey(this)" onmouseover="ChangeCopyCodeIcon(this)" onfocusin="ChangeCopyCodeIcon(this)" onmouseout="ChangeCopyCodeIcon(this)" onfocusout="ChangeCopyCodeIcon(this)" tabindex="0"><img class="copyCodeImage" name="ccImage" align="absmiddle" src="../local/copycode.gif" />Copy Code
                  </span></th></tr><tr><td colspan="2"><pre>public ClientInformation Register(string userName){  // retrieve session information  string roleId = RoleEnvironment.CurrentRoleInstance.Id;  string sessionId = OperationContext.Current.SessionId;  IClientNotification callback = OperationContext.Current.GetCallbackChannel&lt;IClientNotification&gt;();  SessionInformation session;  if (SessionManager.CreateOrUpdateSession(sessionId, userName, roleId, callback, out session))  {    // ensure that the session is killed when channel is closed    OperationContext.Current.Channel.Closed += (sender, e) =&gt;    {      SessionManager.RemoveSession(sessionId);      NotifyConnectedClients(session);<b>      WorkerRole.NotifyAllNodes(session);</b>      Trace.TraceInformation("Session '{0}' by user '{1}' has been closed in role '{2}'.", sessionId, userName, roleId);    };    Trace.TraceInformation("Session '{0}' by user '{1}' has been opened in role '{2}'.", sessionId, userName, roleId);  }  // Notify clients connected to this role  NotifyConnectedClients(session);<b>  // Notify other worker roles</b><b>  WorkerRole.NotifyAllNodes(session);</b>  return new ClientInformation()  {    SessionId = sessionId,    UserName = userName,    RoleId = roleId  };}</pre></td></tr></table></span></div><br /></li>
          <li>If you implement the code in Visual Basic, locate the <b>Register</b> method and insert a call to <b>NotifyAllNodes</b> immediately after the call to <b>NotifyConnectedClients</b>. In addition, locate the <b>OnClosed</b> event handler that handles the <b>Closed</b> event of the channel and insert a call to <b>NotifyAllNodes</b> after the call to <b>NotifyConnectedClients</b>. This ensures that worker roles are alerted both when clients open and when they close a session.<div class="code"><span codeLanguage="VisualBasicUsage"><table width="100%" cellspacing="0" cellpadding="0"><tr><th>Visual Basic</th><th><span class="copyCode" onclick="CopyCode(this)" onkeypress="CopyCode_CheckKey(this)" onmouseover="ChangeCopyCodeIcon(this)" onfocusin="ChangeCopyCodeIcon(this)" onmouseout="ChangeCopyCodeIcon(this)" onfocusout="ChangeCopyCodeIcon(this)" tabindex="0"><img class="copyCodeImage" name="ccImage" align="absmiddle" src="../local/copycode.gif" />Copy Code
                  </span></th></tr><tr><td colspan="2"><pre>' &lt;returns&gt;The ClientInformation object for the new session.&lt;/returns&gt;        Public Function Register(ByVal userName As String) As ClientInformation Implements IChatService.Register  ' retrieve session information  Dim roleId As String = RoleEnvironment.CurrentRoleInstance.Id  Dim sessionId As String = OperationContext.Current.SessionId  Dim callback As IClientNotification = OperationContext.Current.GetCallbackChannel(Of IClientNotification)()  Dim session As SessionInformation  If SessionManager.CreateOrUpdateSession(sessionId, userName, roleId, callback, session) Then    ' ensure that the session is killed when channel is closed    AddHandler OperationContext.Current.Channel.Closed, Function(sender, e) OnClosed(sender, e, sessionId, session, userName, roleId)    Trace.TraceInformation("Session '{0}' by user '{1}' has been opened in role '{2}'.", sessionId, userName, roleId)  End If  ' Notify clients connected to this role  NotifyConnectedClients(session)<b>' Notify other worker roles</b><b>  WorkerRole.NotifyAllNodes(session)</b>  Return New ClientInformation() With {.SessionId = sessionId, .UserName = userName, .RoleId = roleId}End FunctionPrivate Function OnClosed(ByVal sender As Object, ByVal e As Object, ByVal sessionId As String, ByVal session As SessionInformation, ByVal userName As String, ByVal roleId As String) As Object  SessionManager.RemoveSession(sessionId)  NotifyConnectedClients(session)<b>  WorkerRole.NotifyAllNodes(session)</b>  Trace.TraceInformation("Session '{0}' by user '{1}' has been closed in role '{2}'.", sessionId, userName, roleId)  Return NothingEnd Function</pre></td></tr></table></span></div><br /></li>
          <li>Next, replace the body of the <b>SendMessage</b> method with the code shown (highlighted) below. The changed code determines whether a client is local or remote and if necessary, forwards the message to the target worker role.<p> (Code Snippet – <i>Windows Azure Worker Role Communication</i>–<i>Ex02 Multi-Role SendMessage - CS</i>)</p><div class="code"><span codeLanguage="CSharp"><table width="100%" cellspacing="0" cellpadding="0"><tr><th>C#</th><th><span class="copyCode" onclick="CopyCode(this)" onkeypress="CopyCode_CheckKey(this)" onmouseover="ChangeCopyCodeIcon(this)" onfocusin="ChangeCopyCodeIcon(this)" onmouseout="ChangeCopyCodeIcon(this)" onfocusout="ChangeCopyCodeIcon(this)" tabindex="0"><img class="copyCodeImage" name="ccImage" align="absmiddle" src="../local/copycode.gif" />Copy Code
                  </span></th></tr><tr><td colspan="2"><pre>public void SendMessage(string message, string sessionId){<b>  string fromSessionId = OperationContext.Current.SessionId;</b><b>  SessionInformation toSession = SessionManager.GetSession(sessionId);</b><b>  // if recipient is connected to this role, deliver the message to the </b><b>  // recipient; otherwise, forward the message to the recipient's role</b><b>  if (toSession != null)</b><b>  {</b><b>    if (toSession.RoleId == RoleEnvironment.CurrentRoleInstance.Id)</b><b>    {</b><b>      this.DeliverMessage(message, fromSessionId, sessionId);</b><b>    }</b><b>    else</b><b>    {</b><b>      WorkerRole.ForwardMessage(message, fromSessionId, sessionId);</b><b>    }</b><b>  }</b>}</pre></td></tr></table></span></div><br /><p>(Code Snippet – <i>Windows Azure Worker Role Communication</i>–<i>Ex02 Multi-Role SendMessage - VB</i>)</p><div class="code"><span codeLanguage="VisualBasicUsage"><table width="100%" cellspacing="0" cellpadding="0"><tr><th>Visual Basic</th><th><span class="copyCode" onclick="CopyCode(this)" onkeypress="CopyCode_CheckKey(this)" onmouseover="ChangeCopyCodeIcon(this)" onfocusin="ChangeCopyCodeIcon(this)" onmouseout="ChangeCopyCodeIcon(this)" onfocusout="ChangeCopyCodeIcon(this)" tabindex="0"><img class="copyCodeImage" name="ccImage" align="absmiddle" src="../local/copycode.gif" />Copy Code
                  </span></th></tr><tr><td colspan="2"><pre>Public Sub SendMessage(ByVal message As String, ByVal sessionId As String) Implements IChatService.SendMessage<b>  Dim fromSessionId As String = OperationContext.Current.SessionId</b><b>  Dim toSession As SessionInformation = SessionManager.GetSession(sessionId)</b><b>  ' if recipient is connected to this role, deliver the message to the </b><b>  ' recipient; otherwise, forward the message to the recipient's role</b><b>  If toSession IsNot Nothing Then</b><b>    If toSession.RoleId = RoleEnvironment.CurrentRoleInstance.Id Then</b><b>      Me.DeliverMessage(message, fromSessionId, sessionId)</b><b>    Else</b><b>      WorkerRole.ForwardMessage(message, fromSessionId, sessionId)</b><b>    End If</b><b>  End If</b>End Sub</pre></td></tr></table></span></div><br /><div class="alert"><table width="100%" cellspacing="0" cellpadding="0"><tr><th align="left"><img class="note" src="../local/note.gif" />Note:</th></tr><tr><td>The <b>SendMessage</b> operation retrieves the target session, obtains its role ID and compares it with the ID of the current worker role. If the IDs match, the message is sent directly to the client using <b>DeliverMessage</b>; otherwise, the message is forwarded to the target role using <b>WorkerRole.ForwardMessage</b>.</td></tr></table><p /></div></li>
        </ol>
        <p>
          <b>
          </b>
        </p>
        <a name="_Toc249249700" href="#">
          <span />
        </a>
        <p>
          <b>Verification</b>
        </p>
        <p>You will now test the updated solution using two instances of the worker role. To determine whether clients connected to different worker roles are able to communicate with each other, you will start two instances of the client application and connect each one to a different role. Finally, you will exchange messages between these two instances to establish that messages and notifications flow between worker roles.</p>
        <ol>
          <li>Press <b>F5</b> to launch the cloud project in the development fabric.</li>
          <li>Switch to the development fabric UI and ensure that the service has started successfully. Notice that two instances of the worker role are currently active.</li>
          <li>In <b>Solution Explorer</b>, right-click the <b>AzureTalk.Client</b> project, point to <b>Debug</b> and select <b>Start new instance</b>.</li>
          <li>In the main window of the application, enter a user name for the first client and click <b>Sign In</b>. </li>
          <li>Start a second instance of the client application and sign in using a different user name. Ensure that the second client connects to a different worker role than the first client. You can verify the connected role by checking the title bar of the application that shows the name of the current user and the ID of the worker role where the client is connected. Each client should connect to a different worker role.<div class="alert"><table width="100%" cellspacing="0" cellpadding="0"><tr><th align="left"><img class="note" src="../local/note.gif" />Note:</th></tr><tr><td>The load balancer determines which instance of the worker role responds to a client's request. The development fabric typically assigns connections in round robin fashion, so the second client should normally start a session in a different worker role when it connects.  If necessary, restart one of the client instances until both clients have sessions in different worker roles.</td></tr></table><p /></div><br /><p><img src="images\547d0da4-8562-42e2-8760-13309c7e1ef9.png" /></p><p><b>Figure 4</b><br /><i>Verifying the connected worker role ID of the client</i></p><br /></li>
          <li>In the second client, notice how the online users list includes the first client. Switch to the first instance of the client application to make sure that the service notified it about the new active user. This shows that notifications flow from the role where the second user connected to the first role and then back to the client application. Contrast this with the result obtained after you completed the first exercise, where clients in different roles were unaware of each other.</li>
          <li>Switch to the development fabric UI and examine the logs for each of the worker roles. View the entries for the sessions that just started and see how the log registers local and remote sessions.<p><img src="images\4c12693b-fac9-41ad-8157-d2f1ef14b702.png" /></p><p><b>Figure 5</b><br /><i>Local and remote sessions logged in the worker role log</i></p><br /></li>
          <li>In the first instance of the client application, select the other active user from the list, type a message and click <b>Send</b>. Switch to the second instance of the application to verify that the service delivered the message.</li>
          <li>In the second instance, type a reply and click <b>Send</b> once again. Notice that the service delivers messages across worker roles in both directions.</li>
          <li>Finally, click <b>Sign out</b> in one of the instances of the client application.  Switch to the other instance and notice that the server immediately notifies the client attached to the role about the session ending in the other role.</li>
        </ol>
        <br />
      </div>
      <div id="footer">
        <div class="footerLine">
          <img src="../local/footer.gif" alt="Footer image" width="100%" height="3px" />
        </div>To give feedback please write to azcfeed@microsoft.com<p />Copyright © 2010 by Microsoft Corporation. All rights reserved.</div>
    </div>
  </body>
</html>